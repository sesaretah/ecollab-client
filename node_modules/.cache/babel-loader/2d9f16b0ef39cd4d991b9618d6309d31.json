{"ast":null,"code":"/* eslint-env node */\n'use strict'; // SDP helpers.\n\nconst SDPUtils = {}; // Generate an alphanumeric identifier for cname or mids.\n// TODO: use UUIDs instead? https://gist.github.com/jed/982883\n\nSDPUtils.generateIdentifier = function () {\n  return Math.random().toString(36).substr(2, 10);\n}; // The RTCP CNAME used by all peerconnections from the same JS.\n\n\nSDPUtils.localCName = SDPUtils.generateIdentifier(); // Splits SDP into lines, dealing with both CRLF and LF.\n\nSDPUtils.splitLines = function (blob) {\n  return blob.trim().split('\\n').map(line => line.trim());\n}; // Splits SDP into sessionpart and mediasections. Ensures CRLF.\n\n\nSDPUtils.splitSections = function (blob) {\n  const parts = blob.split('\\nm=');\n  return parts.map((part, index) => (index > 0 ? 'm=' + part : part).trim() + '\\r\\n');\n}; // Returns the session description.\n\n\nSDPUtils.getDescription = function (blob) {\n  const sections = SDPUtils.splitSections(blob);\n  return sections && sections[0];\n}; // Returns the individual media sections.\n\n\nSDPUtils.getMediaSections = function (blob) {\n  const sections = SDPUtils.splitSections(blob);\n  sections.shift();\n  return sections;\n}; // Returns lines that start with a certain prefix.\n\n\nSDPUtils.matchPrefix = function (blob, prefix) {\n  return SDPUtils.splitLines(blob).filter(line => line.indexOf(prefix) === 0);\n}; // Parses an ICE candidate line. Sample input:\n// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\n// rport 55996\"\n// Input can be prefixed with a=.\n\n\nSDPUtils.parseCandidate = function (line) {\n  let parts; // Parse both variants.\n\n  if (line.indexOf('a=candidate:') === 0) {\n    parts = line.substring(12).split(' ');\n  } else {\n    parts = line.substring(10).split(' ');\n  }\n\n  const candidate = {\n    foundation: parts[0],\n    component: {\n      1: 'rtp',\n      2: 'rtcp'\n    }[parts[1]] || parts[1],\n    protocol: parts[2].toLowerCase(),\n    priority: parseInt(parts[3], 10),\n    ip: parts[4],\n    address: parts[4],\n    // address is an alias for ip.\n    port: parseInt(parts[5], 10),\n    // skip parts[6] == 'typ'\n    type: parts[7]\n  };\n\n  for (let i = 8; i < parts.length; i += 2) {\n    switch (parts[i]) {\n      case 'raddr':\n        candidate.relatedAddress = parts[i + 1];\n        break;\n\n      case 'rport':\n        candidate.relatedPort = parseInt(parts[i + 1], 10);\n        break;\n\n      case 'tcptype':\n        candidate.tcpType = parts[i + 1];\n        break;\n\n      case 'ufrag':\n        candidate.ufrag = parts[i + 1]; // for backward compatibility.\n\n        candidate.usernameFragment = parts[i + 1];\n        break;\n\n      default:\n        // extension handling, in particular ufrag. Don't overwrite.\n        if (candidate[parts[i]] === undefined) {\n          candidate[parts[i]] = parts[i + 1];\n        }\n\n        break;\n    }\n  }\n\n  return candidate;\n}; // Translates a candidate object into SDP candidate attribute.\n// This does not include the a= prefix!\n\n\nSDPUtils.writeCandidate = function (candidate) {\n  const sdp = [];\n  sdp.push(candidate.foundation);\n  const component = candidate.component;\n\n  if (component === 'rtp') {\n    sdp.push(1);\n  } else if (component === 'rtcp') {\n    sdp.push(2);\n  } else {\n    sdp.push(component);\n  }\n\n  sdp.push(candidate.protocol.toUpperCase());\n  sdp.push(candidate.priority);\n  sdp.push(candidate.address || candidate.ip);\n  sdp.push(candidate.port);\n  const type = candidate.type;\n  sdp.push('typ');\n  sdp.push(type);\n\n  if (type !== 'host' && candidate.relatedAddress && candidate.relatedPort) {\n    sdp.push('raddr');\n    sdp.push(candidate.relatedAddress);\n    sdp.push('rport');\n    sdp.push(candidate.relatedPort);\n  }\n\n  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {\n    sdp.push('tcptype');\n    sdp.push(candidate.tcpType);\n  }\n\n  if (candidate.usernameFragment || candidate.ufrag) {\n    sdp.push('ufrag');\n    sdp.push(candidate.usernameFragment || candidate.ufrag);\n  }\n\n  return 'candidate:' + sdp.join(' ');\n}; // Parses an ice-options line, returns an array of option tags.\n// Sample input:\n// a=ice-options:foo bar\n\n\nSDPUtils.parseIceOptions = function (line) {\n  return line.substr(14).split(' ');\n}; // Parses a rtpmap line, returns RTCRtpCoddecParameters. Sample input:\n// a=rtpmap:111 opus/48000/2\n\n\nSDPUtils.parseRtpMap = function (line) {\n  let parts = line.substr(9).split(' ');\n  const parsed = {\n    payloadType: parseInt(parts.shift(), 10) // was: id\n\n  };\n  parts = parts[0].split('/');\n  parsed.name = parts[0];\n  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\n\n  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1; // legacy alias, got renamed back to channels in ORTC.\n\n  parsed.numChannels = parsed.channels;\n  return parsed;\n}; // Generates a rtpmap line from RTCRtpCodecCapability or\n// RTCRtpCodecParameters.\n\n\nSDPUtils.writeRtpMap = function (codec) {\n  let pt = codec.payloadType;\n\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n\n  const channels = codec.channels || codec.numChannels || 1;\n  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate + (channels !== 1 ? '/' + channels : '') + '\\r\\n';\n}; // Parses a extmap line (headerextension from RFC 5285). Sample input:\n// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset\n\n\nSDPUtils.parseExtmap = function (line) {\n  const parts = line.substr(9).split(' ');\n  return {\n    id: parseInt(parts[0], 10),\n    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',\n    uri: parts[1]\n  };\n}; // Generates an extmap line from RTCRtpHeaderExtensionParameters or\n// RTCRtpHeaderExtension.\n\n\nSDPUtils.writeExtmap = function (headerExtension) {\n  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== 'sendrecv' ? '/' + headerExtension.direction : '') + ' ' + headerExtension.uri + '\\r\\n';\n}; // Parses a fmtp line, returns dictionary. Sample input:\n// a=fmtp:96 vbr=on;cng=on\n// Also deals with vbr=on; cng=on\n\n\nSDPUtils.parseFmtp = function (line) {\n  const parsed = {};\n  let kv;\n  const parts = line.substr(line.indexOf(' ') + 1).split(';');\n\n  for (let j = 0; j < parts.length; j++) {\n    kv = parts[j].trim().split('=');\n    parsed[kv[0].trim()] = kv[1];\n  }\n\n  return parsed;\n}; // Generates a fmtp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\n\n\nSDPUtils.writeFmtp = function (codec) {\n  let line = '';\n  let pt = codec.payloadType;\n\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n\n  if (codec.parameters && Object.keys(codec.parameters).length) {\n    const params = [];\n    Object.keys(codec.parameters).forEach(param => {\n      if (codec.parameters[param] !== undefined) {\n        params.push(param + '=' + codec.parameters[param]);\n      } else {\n        params.push(param);\n      }\n    });\n    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\\r\\n';\n  }\n\n  return line;\n}; // Parses a rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\n// a=rtcp-fb:98 nack rpsi\n\n\nSDPUtils.parseRtcpFb = function (line) {\n  const parts = line.substr(line.indexOf(' ') + 1).split(' ');\n  return {\n    type: parts.shift(),\n    parameter: parts.join(' ')\n  };\n}; // Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\n\n\nSDPUtils.writeRtcpFb = function (codec) {\n  let lines = '';\n  let pt = codec.payloadType;\n\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n\n  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\n    // FIXME: special handling for trr-int?\n    codec.rtcpFeedback.forEach(fb => {\n      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type + (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') + '\\r\\n';\n    });\n  }\n\n  return lines;\n}; // Parses a RFC 5576 ssrc media attribute. Sample input:\n// a=ssrc:3735928559 cname:something\n\n\nSDPUtils.parseSsrcMedia = function (line) {\n  const sp = line.indexOf(' ');\n  const parts = {\n    ssrc: parseInt(line.substr(7, sp - 7), 10)\n  };\n  const colon = line.indexOf(':', sp);\n\n  if (colon > -1) {\n    parts.attribute = line.substr(sp + 1, colon - sp - 1);\n    parts.value = line.substr(colon + 1);\n  } else {\n    parts.attribute = line.substr(sp + 1);\n  }\n\n  return parts;\n}; // Parse a ssrc-group line (see RFC 5576). Sample input:\n// a=ssrc-group:semantics 12 34\n\n\nSDPUtils.parseSsrcGroup = function (line) {\n  const parts = line.substr(13).split(' ');\n  return {\n    semantics: parts.shift(),\n    ssrcs: parts.map(ssrc => parseInt(ssrc, 10))\n  };\n}; // Extracts the MID (RFC 5888) from a media section.\n// Returns the MID or undefined if no mid line was found.\n\n\nSDPUtils.getMid = function (mediaSection) {\n  const mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];\n\n  if (mid) {\n    return mid.substr(6);\n  }\n}; // Parses a fingerprint line for DTLS-SRTP.\n\n\nSDPUtils.parseFingerprint = function (line) {\n  const parts = line.substr(14).split(' ');\n  return {\n    algorithm: parts[0].toLowerCase(),\n    // algorithm is case-sensitive in Edge.\n    value: parts[1].toUpperCase() // the definition is upper-case in RFC 4572.\n\n  };\n}; // Extracts DTLS parameters from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the fingerprint line as input. See also getIceParameters.\n\n\nSDPUtils.getDtlsParameters = function (mediaSection, sessionpart) {\n  const lines = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=fingerprint:'); // Note: a=setup line is ignored since we use the 'auto' role in Edge.\n\n  return {\n    role: 'auto',\n    fingerprints: lines.map(SDPUtils.parseFingerprint)\n  };\n}; // Serializes DTLS parameters to SDP.\n\n\nSDPUtils.writeDtlsParameters = function (params, setupType) {\n  let sdp = 'a=setup:' + setupType + '\\r\\n';\n  params.fingerprints.forEach(fp => {\n    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\\r\\n';\n  });\n  return sdp;\n}; // Parses a=crypto lines into\n//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members\n\n\nSDPUtils.parseCryptoLine = function (line) {\n  const parts = line.substr(9).split(' ');\n  return {\n    tag: parseInt(parts[0], 10),\n    cryptoSuite: parts[1],\n    keyParams: parts[2],\n    sessionParams: parts.slice(3)\n  };\n};\n\nSDPUtils.writeCryptoLine = function (parameters) {\n  return 'a=crypto:' + parameters.tag + ' ' + parameters.cryptoSuite + ' ' + (typeof parameters.keyParams === 'object' ? SDPUtils.writeCryptoKeyParams(parameters.keyParams) : parameters.keyParams) + (parameters.sessionParams ? ' ' + parameters.sessionParams.join(' ') : '') + '\\r\\n';\n}; // Parses the crypto key parameters into\n//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*\n\n\nSDPUtils.parseCryptoKeyParams = function (keyParams) {\n  if (keyParams.indexOf('inline:') !== 0) {\n    return null;\n  }\n\n  const parts = keyParams.substr(7).split('|');\n  return {\n    keyMethod: 'inline',\n    keySalt: parts[0],\n    lifeTime: parts[1],\n    mkiValue: parts[2] ? parts[2].split(':')[0] : undefined,\n    mkiLength: parts[2] ? parts[2].split(':')[1] : undefined\n  };\n};\n\nSDPUtils.writeCryptoKeyParams = function (keyParams) {\n  return keyParams.keyMethod + ':' + keyParams.keySalt + (keyParams.lifeTime ? '|' + keyParams.lifeTime : '') + (keyParams.mkiValue && keyParams.mkiLength ? '|' + keyParams.mkiValue + ':' + keyParams.mkiLength : '');\n}; // Extracts all SDES parameters.\n\n\nSDPUtils.getCryptoParameters = function (mediaSection, sessionpart) {\n  const lines = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=crypto:');\n  return lines.map(SDPUtils.parseCryptoLine);\n}; // Parses ICE information from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the ice-ufrag and ice-pwd lines as input.\n\n\nSDPUtils.getIceParameters = function (mediaSection, sessionpart) {\n  const ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=ice-ufrag:')[0];\n  const pwd = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=ice-pwd:')[0];\n\n  if (!(ufrag && pwd)) {\n    return null;\n  }\n\n  return {\n    usernameFragment: ufrag.substr(12),\n    password: pwd.substr(10)\n  };\n}; // Serializes ICE parameters to SDP.\n\n\nSDPUtils.writeIceParameters = function (params) {\n  let sdp = 'a=ice-ufrag:' + params.usernameFragment + '\\r\\n' + 'a=ice-pwd:' + params.password + '\\r\\n';\n\n  if (params.iceLite) {\n    sdp += 'a=ice-lite\\r\\n';\n  }\n\n  return sdp;\n}; // Parses the SDP media section and returns RTCRtpParameters.\n\n\nSDPUtils.parseRtpParameters = function (mediaSection) {\n  const description = {\n    codecs: [],\n    headerExtensions: [],\n    fecMechanisms: [],\n    rtcp: []\n  };\n  const lines = SDPUtils.splitLines(mediaSection);\n  const mline = lines[0].split(' ');\n\n  for (let i = 3; i < mline.length; i++) {\n    // find all codecs from mline[3..]\n    const pt = mline[i];\n    const rtpmapline = SDPUtils.matchPrefix(mediaSection, 'a=rtpmap:' + pt + ' ')[0];\n\n    if (rtpmapline) {\n      const codec = SDPUtils.parseRtpMap(rtpmapline);\n      const fmtps = SDPUtils.matchPrefix(mediaSection, 'a=fmtp:' + pt + ' '); // Only the first a=fmtp:<pt> is considered.\n\n      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\n      codec.rtcpFeedback = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-fb:' + pt + ' ').map(SDPUtils.parseRtcpFb);\n      description.codecs.push(codec); // parse FEC mechanisms from rtpmap lines.\n\n      switch (codec.name.toUpperCase()) {\n        case 'RED':\n        case 'ULPFEC':\n          description.fecMechanisms.push(codec.name.toUpperCase());\n          break;\n\n        default:\n          // only RED and ULPFEC are recognized as FEC mechanisms.\n          break;\n      }\n    }\n  }\n\n  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(line => {\n    description.headerExtensions.push(SDPUtils.parseExtmap(line));\n  }); // FIXME: parse rtcp.\n\n  return description;\n}; // Generates parts of the SDP media section describing the capabilities /\n// parameters.\n\n\nSDPUtils.writeRtpDescription = function (kind, caps) {\n  let sdp = ''; // Build the mline.\n\n  sdp += 'm=' + kind + ' ';\n  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.\n\n  sdp += ' UDP/TLS/RTP/SAVPF ';\n  sdp += caps.codecs.map(codec => {\n    if (codec.preferredPayloadType !== undefined) {\n      return codec.preferredPayloadType;\n    }\n\n    return codec.payloadType;\n  }).join(' ') + '\\r\\n';\n  sdp += 'c=IN IP4 0.0.0.0\\r\\n';\n  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\\r\\n'; // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\n\n  caps.codecs.forEach(codec => {\n    sdp += SDPUtils.writeRtpMap(codec);\n    sdp += SDPUtils.writeFmtp(codec);\n    sdp += SDPUtils.writeRtcpFb(codec);\n  });\n  let maxptime = 0;\n  caps.codecs.forEach(codec => {\n    if (codec.maxptime > maxptime) {\n      maxptime = codec.maxptime;\n    }\n  });\n\n  if (maxptime > 0) {\n    sdp += 'a=maxptime:' + maxptime + '\\r\\n';\n  }\n\n  if (caps.headerExtensions) {\n    caps.headerExtensions.forEach(extension => {\n      sdp += SDPUtils.writeExtmap(extension);\n    });\n  } // FIXME: write fecMechanisms.\n\n\n  return sdp;\n}; // Parses the SDP media section and returns an array of\n// RTCRtpEncodingParameters.\n\n\nSDPUtils.parseRtpEncodingParameters = function (mediaSection) {\n  const encodingParameters = [];\n  const description = SDPUtils.parseRtpParameters(mediaSection);\n  const hasRed = description.fecMechanisms.indexOf('RED') !== -1;\n  const hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1; // filter a=ssrc:... cname:, ignore PlanB-msid\n\n  const ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(line => SDPUtils.parseSsrcMedia(line)).filter(parts => parts.attribute === 'cname');\n  const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\n  let secondarySsrc;\n  const flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID').map(line => {\n    const parts = line.substr(17).split(' ');\n    return parts.map(part => parseInt(part, 10));\n  });\n\n  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\n    secondarySsrc = flows[0][1];\n  }\n\n  description.codecs.forEach(codec => {\n    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {\n      let encParam = {\n        ssrc: primarySsrc,\n        codecPayloadType: parseInt(codec.parameters.apt, 10)\n      };\n\n      if (primarySsrc && secondarySsrc) {\n        encParam.rtx = {\n          ssrc: secondarySsrc\n        };\n      }\n\n      encodingParameters.push(encParam);\n\n      if (hasRed) {\n        encParam = JSON.parse(JSON.stringify(encParam));\n        encParam.fec = {\n          ssrc: primarySsrc,\n          mechanism: hasUlpfec ? 'red+ulpfec' : 'red'\n        };\n        encodingParameters.push(encParam);\n      }\n    }\n  });\n\n  if (encodingParameters.length === 0 && primarySsrc) {\n    encodingParameters.push({\n      ssrc: primarySsrc\n    });\n  } // we support both b=AS and b=TIAS but interpret AS as TIAS.\n\n\n  let bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');\n\n  if (bandwidth.length) {\n    if (bandwidth[0].indexOf('b=TIAS:') === 0) {\n      bandwidth = parseInt(bandwidth[0].substr(7), 10);\n    } else if (bandwidth[0].indexOf('b=AS:') === 0) {\n      // use formula from JSEP to convert b=AS to TIAS value.\n      bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95 - 50 * 40 * 8;\n    } else {\n      bandwidth = undefined;\n    }\n\n    encodingParameters.forEach(params => {\n      params.maxBitrate = bandwidth;\n    });\n  }\n\n  return encodingParameters;\n}; // parses http://draft.ortc.org/#rtcrtcpparameters*\n\n\nSDPUtils.parseRtcpParameters = function (mediaSection) {\n  const rtcpParameters = {}; // Gets the first SSRC. Note that with RTX there might be multiple\n  // SSRCs.\n\n  const remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(line => SDPUtils.parseSsrcMedia(line)).filter(obj => obj.attribute === 'cname')[0];\n\n  if (remoteSsrc) {\n    rtcpParameters.cname = remoteSsrc.value;\n    rtcpParameters.ssrc = remoteSsrc.ssrc;\n  } // Edge uses the compound attribute instead of reducedSize\n  // compound is !reducedSize\n\n\n  const rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');\n  rtcpParameters.reducedSize = rsize.length > 0;\n  rtcpParameters.compound = rsize.length === 0; // parses the rtcp-mux attrÑ–bute.\n  // Note that Edge does not support unmuxed RTCP.\n\n  const mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');\n  rtcpParameters.mux = mux.length > 0;\n  return rtcpParameters;\n};\n\nSDPUtils.writeRtcpParameters = function (rtcpParameters) {\n  let sdp = '';\n\n  if (rtcpParameters.reducedSize) {\n    sdp += 'a=rtcp-rsize\\r\\n';\n  }\n\n  if (rtcpParameters.mux) {\n    sdp += 'a=rtcp-mux\\r\\n';\n  }\n\n  if (rtcpParameters.ssrc !== undefined && rtcpParameters.cname) {\n    sdp += 'a=ssrc:' + rtcpParameters.ssrc + ' cname:' + rtcpParameters.cname + '\\r\\n';\n  }\n\n  return sdp;\n}; // parses either a=msid: or a=ssrc:... msid lines and returns\n// the id of the MediaStream and MediaStreamTrack.\n\n\nSDPUtils.parseMsid = function (mediaSection) {\n  let parts;\n  const spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');\n\n  if (spec.length === 1) {\n    parts = spec[0].substr(7).split(' ');\n    return {\n      stream: parts[0],\n      track: parts[1]\n    };\n  }\n\n  const planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(line => SDPUtils.parseSsrcMedia(line)).filter(msidParts => msidParts.attribute === 'msid');\n\n  if (planB.length > 0) {\n    parts = planB[0].value.split(' ');\n    return {\n      stream: parts[0],\n      track: parts[1]\n    };\n  }\n}; // SCTP\n// parses draft-ietf-mmusic-sctp-sdp-26 first and falls back\n// to draft-ietf-mmusic-sctp-sdp-05\n\n\nSDPUtils.parseSctpDescription = function (mediaSection) {\n  const mline = SDPUtils.parseMLine(mediaSection);\n  const maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');\n  let maxMessageSize;\n\n  if (maxSizeLine.length > 0) {\n    maxMessageSize = parseInt(maxSizeLine[0].substr(19), 10);\n  }\n\n  if (isNaN(maxMessageSize)) {\n    maxMessageSize = 65536;\n  }\n\n  const sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');\n\n  if (sctpPort.length > 0) {\n    return {\n      port: parseInt(sctpPort[0].substr(12), 10),\n      protocol: mline.fmt,\n      maxMessageSize\n    };\n  }\n\n  const sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');\n\n  if (sctpMapLines.length > 0) {\n    const parts = sctpMapLines[0].substr(10).split(' ');\n    return {\n      port: parseInt(parts[0], 10),\n      protocol: parts[1],\n      maxMessageSize\n    };\n  }\n}; // SCTP\n// outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers\n// support by now receiving in this format, unless we originally parsed\n// as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line\n// protocol of DTLS/SCTP -- without UDP/ or TCP/)\n\n\nSDPUtils.writeSctpDescription = function (media, sctp) {\n  let output = [];\n\n  if (media.protocol !== 'DTLS/SCTP') {\n    output = ['m=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\\r\\n', 'c=IN IP4 0.0.0.0\\r\\n', 'a=sctp-port:' + sctp.port + '\\r\\n'];\n  } else {\n    output = ['m=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\\r\\n', 'c=IN IP4 0.0.0.0\\r\\n', 'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\\r\\n'];\n  }\n\n  if (sctp.maxMessageSize !== undefined) {\n    output.push('a=max-message-size:' + sctp.maxMessageSize + '\\r\\n');\n  }\n\n  return output.join('');\n}; // Generate a session ID for SDP.\n// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1\n// recommends using a cryptographically random +ve 64-bit value\n// but right now this should be acceptable and within the right range\n\n\nSDPUtils.generateSessionId = function () {\n  return Math.random().toString().substr(2, 21);\n}; // Write boiler plate for start of SDP\n// sessId argument is optional - if not supplied it will\n// be generated randomly\n// sessVersion is optional and defaults to 2\n// sessUser is optional and defaults to 'thisisadapterortc'\n\n\nSDPUtils.writeSessionBoilerplate = function (sessId, sessVer, sessUser) {\n  let sessionId;\n  const version = sessVer !== undefined ? sessVer : 2;\n\n  if (sessId) {\n    sessionId = sessId;\n  } else {\n    sessionId = SDPUtils.generateSessionId();\n  }\n\n  const user = sessUser || 'thisisadapterortc'; // FIXME: sess-id should be an NTP timestamp.\n\n  return 'v=0\\r\\n' + 'o=' + user + ' ' + sessionId + ' ' + version + ' IN IP4 127.0.0.1\\r\\n' + 's=-\\r\\n' + 't=0 0\\r\\n';\n}; // Gets the direction from the mediaSection or the sessionpart.\n\n\nSDPUtils.getDirection = function (mediaSection, sessionpart) {\n  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\n  const lines = SDPUtils.splitLines(mediaSection);\n\n  for (let i = 0; i < lines.length; i++) {\n    switch (lines[i]) {\n      case 'a=sendrecv':\n      case 'a=sendonly':\n      case 'a=recvonly':\n      case 'a=inactive':\n        return lines[i].substr(2);\n\n      default: // FIXME: What should happen here?\n\n    }\n  }\n\n  if (sessionpart) {\n    return SDPUtils.getDirection(sessionpart);\n  }\n\n  return 'sendrecv';\n};\n\nSDPUtils.getKind = function (mediaSection) {\n  const lines = SDPUtils.splitLines(mediaSection);\n  const mline = lines[0].split(' ');\n  return mline[0].substr(2);\n};\n\nSDPUtils.isRejected = function (mediaSection) {\n  return mediaSection.split(' ', 2)[1] === '0';\n};\n\nSDPUtils.parseMLine = function (mediaSection) {\n  const lines = SDPUtils.splitLines(mediaSection);\n  const parts = lines[0].substr(2).split(' ');\n  return {\n    kind: parts[0],\n    port: parseInt(parts[1], 10),\n    protocol: parts[2],\n    fmt: parts.slice(3).join(' ')\n  };\n};\n\nSDPUtils.parseOLine = function (mediaSection) {\n  const line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];\n  const parts = line.substr(2).split(' ');\n  return {\n    username: parts[0],\n    sessionId: parts[1],\n    sessionVersion: parseInt(parts[2], 10),\n    netType: parts[3],\n    addressType: parts[4],\n    address: parts[5]\n  };\n}; // a very naive interpretation of a valid SDP.\n\n\nSDPUtils.isValidSDP = function (blob) {\n  if (typeof blob !== 'string' || blob.length === 0) {\n    return false;\n  }\n\n  const lines = SDPUtils.splitLines(blob);\n\n  for (let i = 0; i < lines.length; i++) {\n    if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {\n      return false;\n    } // TODO: check the modifier a bit more.\n\n  }\n\n  return true;\n}; // Expose public methods.\n\n\nif (typeof module === 'object') {\n  module.exports = SDPUtils;\n}","map":{"version":3,"sources":["/Users/hosseinshafiei/Projects/ecollab/client/node_modules/sdp/sdp.js"],"names":["SDPUtils","generateIdentifier","Math","random","toString","substr","localCName","splitLines","blob","trim","split","map","line","splitSections","parts","part","index","getDescription","sections","getMediaSections","shift","matchPrefix","prefix","filter","indexOf","parseCandidate","substring","candidate","foundation","component","protocol","toLowerCase","priority","parseInt","ip","address","port","type","i","length","relatedAddress","relatedPort","tcpType","ufrag","usernameFragment","undefined","writeCandidate","sdp","push","toUpperCase","join","parseIceOptions","parseRtpMap","parsed","payloadType","name","clockRate","channels","numChannels","writeRtpMap","codec","pt","preferredPayloadType","parseExtmap","id","direction","uri","writeExtmap","headerExtension","preferredId","parseFmtp","kv","j","writeFmtp","parameters","Object","keys","params","forEach","param","parseRtcpFb","parameter","writeRtcpFb","lines","rtcpFeedback","fb","parseSsrcMedia","sp","ssrc","colon","attribute","value","parseSsrcGroup","semantics","ssrcs","getMid","mediaSection","mid","parseFingerprint","algorithm","getDtlsParameters","sessionpart","role","fingerprints","writeDtlsParameters","setupType","fp","parseCryptoLine","tag","cryptoSuite","keyParams","sessionParams","slice","writeCryptoLine","writeCryptoKeyParams","parseCryptoKeyParams","keyMethod","keySalt","lifeTime","mkiValue","mkiLength","getCryptoParameters","getIceParameters","pwd","password","writeIceParameters","iceLite","parseRtpParameters","description","codecs","headerExtensions","fecMechanisms","rtcp","mline","rtpmapline","fmtps","writeRtpDescription","kind","caps","maxptime","extension","parseRtpEncodingParameters","encodingParameters","hasRed","hasUlpfec","primarySsrc","secondarySsrc","flows","apt","encParam","codecPayloadType","rtx","JSON","parse","stringify","fec","mechanism","bandwidth","maxBitrate","parseRtcpParameters","rtcpParameters","remoteSsrc","obj","cname","rsize","reducedSize","compound","mux","writeRtcpParameters","parseMsid","spec","stream","track","planB","msidParts","parseSctpDescription","parseMLine","maxSizeLine","maxMessageSize","isNaN","sctpPort","fmt","sctpMapLines","writeSctpDescription","media","sctp","output","generateSessionId","writeSessionBoilerplate","sessId","sessVer","sessUser","sessionId","version","user","getDirection","getKind","isRejected","parseOLine","username","sessionVersion","netType","addressType","isValidSDP","charAt","module","exports"],"mappings":"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","sourcesContent":["/* eslint-env node */\n'use strict';\n\n// SDP helpers.\nconst SDPUtils = {};\n\n// Generate an alphanumeric identifier for cname or mids.\n// TODO: use UUIDs instead? https://gist.github.com/jed/982883\nSDPUtils.generateIdentifier = function() {\n  return Math.random().toString(36).substr(2, 10);\n};\n\n// The RTCP CNAME used by all peerconnections from the same JS.\nSDPUtils.localCName = SDPUtils.generateIdentifier();\n\n// Splits SDP into lines, dealing with both CRLF and LF.\nSDPUtils.splitLines = function(blob) {\n  return blob.trim().split('\\n').map(line => line.trim());\n};\n// Splits SDP into sessionpart and mediasections. Ensures CRLF.\nSDPUtils.splitSections = function(blob) {\n  const parts = blob.split('\\nm=');\n  return parts.map((part, index) => (index > 0 ?\n    'm=' + part : part).trim() + '\\r\\n');\n};\n\n// Returns the session description.\nSDPUtils.getDescription = function(blob) {\n  const sections = SDPUtils.splitSections(blob);\n  return sections && sections[0];\n};\n\n// Returns the individual media sections.\nSDPUtils.getMediaSections = function(blob) {\n  const sections = SDPUtils.splitSections(blob);\n  sections.shift();\n  return sections;\n};\n\n// Returns lines that start with a certain prefix.\nSDPUtils.matchPrefix = function(blob, prefix) {\n  return SDPUtils.splitLines(blob).filter(line => line.indexOf(prefix) === 0);\n};\n\n// Parses an ICE candidate line. Sample input:\n// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\n// rport 55996\"\n// Input can be prefixed with a=.\nSDPUtils.parseCandidate = function(line) {\n  let parts;\n  // Parse both variants.\n  if (line.indexOf('a=candidate:') === 0) {\n    parts = line.substring(12).split(' ');\n  } else {\n    parts = line.substring(10).split(' ');\n  }\n\n  const candidate = {\n    foundation: parts[0],\n    component: {1: 'rtp', 2: 'rtcp'}[parts[1]] || parts[1],\n    protocol: parts[2].toLowerCase(),\n    priority: parseInt(parts[3], 10),\n    ip: parts[4],\n    address: parts[4], // address is an alias for ip.\n    port: parseInt(parts[5], 10),\n    // skip parts[6] == 'typ'\n    type: parts[7],\n  };\n\n  for (let i = 8; i < parts.length; i += 2) {\n    switch (parts[i]) {\n      case 'raddr':\n        candidate.relatedAddress = parts[i + 1];\n        break;\n      case 'rport':\n        candidate.relatedPort = parseInt(parts[i + 1], 10);\n        break;\n      case 'tcptype':\n        candidate.tcpType = parts[i + 1];\n        break;\n      case 'ufrag':\n        candidate.ufrag = parts[i + 1]; // for backward compatibility.\n        candidate.usernameFragment = parts[i + 1];\n        break;\n      default: // extension handling, in particular ufrag. Don't overwrite.\n        if (candidate[parts[i]] === undefined) {\n          candidate[parts[i]] = parts[i + 1];\n        }\n        break;\n    }\n  }\n  return candidate;\n};\n\n// Translates a candidate object into SDP candidate attribute.\n// This does not include the a= prefix!\nSDPUtils.writeCandidate = function(candidate) {\n  const sdp = [];\n  sdp.push(candidate.foundation);\n\n  const component = candidate.component;\n  if (component === 'rtp') {\n    sdp.push(1);\n  } else if (component === 'rtcp') {\n    sdp.push(2);\n  } else {\n    sdp.push(component);\n  }\n  sdp.push(candidate.protocol.toUpperCase());\n  sdp.push(candidate.priority);\n  sdp.push(candidate.address || candidate.ip);\n  sdp.push(candidate.port);\n\n  const type = candidate.type;\n  sdp.push('typ');\n  sdp.push(type);\n  if (type !== 'host' && candidate.relatedAddress &&\n      candidate.relatedPort) {\n    sdp.push('raddr');\n    sdp.push(candidate.relatedAddress);\n    sdp.push('rport');\n    sdp.push(candidate.relatedPort);\n  }\n  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {\n    sdp.push('tcptype');\n    sdp.push(candidate.tcpType);\n  }\n  if (candidate.usernameFragment || candidate.ufrag) {\n    sdp.push('ufrag');\n    sdp.push(candidate.usernameFragment || candidate.ufrag);\n  }\n  return 'candidate:' + sdp.join(' ');\n};\n\n// Parses an ice-options line, returns an array of option tags.\n// Sample input:\n// a=ice-options:foo bar\nSDPUtils.parseIceOptions = function(line) {\n  return line.substr(14).split(' ');\n};\n\n// Parses a rtpmap line, returns RTCRtpCoddecParameters. Sample input:\n// a=rtpmap:111 opus/48000/2\nSDPUtils.parseRtpMap = function(line) {\n  let parts = line.substr(9).split(' ');\n  const parsed = {\n    payloadType: parseInt(parts.shift(), 10), // was: id\n  };\n\n  parts = parts[0].split('/');\n\n  parsed.name = parts[0];\n  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\n  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\n  // legacy alias, got renamed back to channels in ORTC.\n  parsed.numChannels = parsed.channels;\n  return parsed;\n};\n\n// Generates a rtpmap line from RTCRtpCodecCapability or\n// RTCRtpCodecParameters.\nSDPUtils.writeRtpMap = function(codec) {\n  let pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  const channels = codec.channels || codec.numChannels || 1;\n  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +\n      (channels !== 1 ? '/' + channels : '') + '\\r\\n';\n};\n\n// Parses a extmap line (headerextension from RFC 5285). Sample input:\n// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset\nSDPUtils.parseExtmap = function(line) {\n  const parts = line.substr(9).split(' ');\n  return {\n    id: parseInt(parts[0], 10),\n    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',\n    uri: parts[1],\n  };\n};\n\n// Generates an extmap line from RTCRtpHeaderExtensionParameters or\n// RTCRtpHeaderExtension.\nSDPUtils.writeExtmap = function(headerExtension) {\n  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +\n      (headerExtension.direction && headerExtension.direction !== 'sendrecv'\n        ? '/' + headerExtension.direction\n        : '') +\n      ' ' + headerExtension.uri + '\\r\\n';\n};\n\n// Parses a fmtp line, returns dictionary. Sample input:\n// a=fmtp:96 vbr=on;cng=on\n// Also deals with vbr=on; cng=on\nSDPUtils.parseFmtp = function(line) {\n  const parsed = {};\n  let kv;\n  const parts = line.substr(line.indexOf(' ') + 1).split(';');\n  for (let j = 0; j < parts.length; j++) {\n    kv = parts[j].trim().split('=');\n    parsed[kv[0].trim()] = kv[1];\n  }\n  return parsed;\n};\n\n// Generates a fmtp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeFmtp = function(codec) {\n  let line = '';\n  let pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.parameters && Object.keys(codec.parameters).length) {\n    const params = [];\n    Object.keys(codec.parameters).forEach(param => {\n      if (codec.parameters[param] !== undefined) {\n        params.push(param + '=' + codec.parameters[param]);\n      } else {\n        params.push(param);\n      }\n    });\n    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\\r\\n';\n  }\n  return line;\n};\n\n// Parses a rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\n// a=rtcp-fb:98 nack rpsi\nSDPUtils.parseRtcpFb = function(line) {\n  const parts = line.substr(line.indexOf(' ') + 1).split(' ');\n  return {\n    type: parts.shift(),\n    parameter: parts.join(' '),\n  };\n};\n\n// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeRtcpFb = function(codec) {\n  let lines = '';\n  let pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\n    // FIXME: special handling for trr-int?\n    codec.rtcpFeedback.forEach(fb => {\n      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +\n      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +\n          '\\r\\n';\n    });\n  }\n  return lines;\n};\n\n// Parses a RFC 5576 ssrc media attribute. Sample input:\n// a=ssrc:3735928559 cname:something\nSDPUtils.parseSsrcMedia = function(line) {\n  const sp = line.indexOf(' ');\n  const parts = {\n    ssrc: parseInt(line.substr(7, sp - 7), 10),\n  };\n  const colon = line.indexOf(':', sp);\n  if (colon > -1) {\n    parts.attribute = line.substr(sp + 1, colon - sp - 1);\n    parts.value = line.substr(colon + 1);\n  } else {\n    parts.attribute = line.substr(sp + 1);\n  }\n  return parts;\n};\n\n// Parse a ssrc-group line (see RFC 5576). Sample input:\n// a=ssrc-group:semantics 12 34\nSDPUtils.parseSsrcGroup = function(line) {\n  const parts = line.substr(13).split(' ');\n  return {\n    semantics: parts.shift(),\n    ssrcs: parts.map(ssrc => parseInt(ssrc, 10)),\n  };\n};\n\n// Extracts the MID (RFC 5888) from a media section.\n// Returns the MID or undefined if no mid line was found.\nSDPUtils.getMid = function(mediaSection) {\n  const mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];\n  if (mid) {\n    return mid.substr(6);\n  }\n};\n\n// Parses a fingerprint line for DTLS-SRTP.\nSDPUtils.parseFingerprint = function(line) {\n  const parts = line.substr(14).split(' ');\n  return {\n    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.\n    value: parts[1].toUpperCase(), // the definition is upper-case in RFC 4572.\n  };\n};\n\n// Extracts DTLS parameters from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the fingerprint line as input. See also getIceParameters.\nSDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {\n  const lines = SDPUtils.matchPrefix(mediaSection + sessionpart,\n    'a=fingerprint:');\n  // Note: a=setup line is ignored since we use the 'auto' role in Edge.\n  return {\n    role: 'auto',\n    fingerprints: lines.map(SDPUtils.parseFingerprint),\n  };\n};\n\n// Serializes DTLS parameters to SDP.\nSDPUtils.writeDtlsParameters = function(params, setupType) {\n  let sdp = 'a=setup:' + setupType + '\\r\\n';\n  params.fingerprints.forEach(fp => {\n    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\\r\\n';\n  });\n  return sdp;\n};\n\n// Parses a=crypto lines into\n//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members\nSDPUtils.parseCryptoLine = function(line) {\n  const parts = line.substr(9).split(' ');\n  return {\n    tag: parseInt(parts[0], 10),\n    cryptoSuite: parts[1],\n    keyParams: parts[2],\n    sessionParams: parts.slice(3),\n  };\n};\n\nSDPUtils.writeCryptoLine = function(parameters) {\n  return 'a=crypto:' + parameters.tag + ' ' +\n    parameters.cryptoSuite + ' ' +\n    (typeof parameters.keyParams === 'object'\n      ? SDPUtils.writeCryptoKeyParams(parameters.keyParams)\n      : parameters.keyParams) +\n    (parameters.sessionParams ? ' ' + parameters.sessionParams.join(' ') : '') +\n    '\\r\\n';\n};\n\n// Parses the crypto key parameters into\n//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*\nSDPUtils.parseCryptoKeyParams = function(keyParams) {\n  if (keyParams.indexOf('inline:') !== 0) {\n    return null;\n  }\n  const parts = keyParams.substr(7).split('|');\n  return {\n    keyMethod: 'inline',\n    keySalt: parts[0],\n    lifeTime: parts[1],\n    mkiValue: parts[2] ? parts[2].split(':')[0] : undefined,\n    mkiLength: parts[2] ? parts[2].split(':')[1] : undefined,\n  };\n};\n\nSDPUtils.writeCryptoKeyParams = function(keyParams) {\n  return keyParams.keyMethod + ':'\n    + keyParams.keySalt +\n    (keyParams.lifeTime ? '|' + keyParams.lifeTime : '') +\n    (keyParams.mkiValue && keyParams.mkiLength\n      ? '|' + keyParams.mkiValue + ':' + keyParams.mkiLength\n      : '');\n};\n\n// Extracts all SDES parameters.\nSDPUtils.getCryptoParameters = function(mediaSection, sessionpart) {\n  const lines = SDPUtils.matchPrefix(mediaSection + sessionpart,\n    'a=crypto:');\n  return lines.map(SDPUtils.parseCryptoLine);\n};\n\n// Parses ICE information from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the ice-ufrag and ice-pwd lines as input.\nSDPUtils.getIceParameters = function(mediaSection, sessionpart) {\n  const ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart,\n    'a=ice-ufrag:')[0];\n  const pwd = SDPUtils.matchPrefix(mediaSection + sessionpart,\n    'a=ice-pwd:')[0];\n  if (!(ufrag && pwd)) {\n    return null;\n  }\n  return {\n    usernameFragment: ufrag.substr(12),\n    password: pwd.substr(10),\n  };\n};\n\n// Serializes ICE parameters to SDP.\nSDPUtils.writeIceParameters = function(params) {\n  let sdp = 'a=ice-ufrag:' + params.usernameFragment + '\\r\\n' +\n      'a=ice-pwd:' + params.password + '\\r\\n';\n  if (params.iceLite) {\n    sdp += 'a=ice-lite\\r\\n';\n  }\n  return sdp;\n};\n\n// Parses the SDP media section and returns RTCRtpParameters.\nSDPUtils.parseRtpParameters = function(mediaSection) {\n  const description = {\n    codecs: [],\n    headerExtensions: [],\n    fecMechanisms: [],\n    rtcp: [],\n  };\n  const lines = SDPUtils.splitLines(mediaSection);\n  const mline = lines[0].split(' ');\n  for (let i = 3; i < mline.length; i++) { // find all codecs from mline[3..]\n    const pt = mline[i];\n    const rtpmapline = SDPUtils.matchPrefix(\n      mediaSection, 'a=rtpmap:' + pt + ' ')[0];\n    if (rtpmapline) {\n      const codec = SDPUtils.parseRtpMap(rtpmapline);\n      const fmtps = SDPUtils.matchPrefix(\n        mediaSection, 'a=fmtp:' + pt + ' ');\n      // Only the first a=fmtp:<pt> is considered.\n      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\n      codec.rtcpFeedback = SDPUtils.matchPrefix(\n        mediaSection, 'a=rtcp-fb:' + pt + ' ')\n        .map(SDPUtils.parseRtcpFb);\n      description.codecs.push(codec);\n      // parse FEC mechanisms from rtpmap lines.\n      switch (codec.name.toUpperCase()) {\n        case 'RED':\n        case 'ULPFEC':\n          description.fecMechanisms.push(codec.name.toUpperCase());\n          break;\n        default: // only RED and ULPFEC are recognized as FEC mechanisms.\n          break;\n      }\n    }\n  }\n  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(line => {\n    description.headerExtensions.push(SDPUtils.parseExtmap(line));\n  });\n  // FIXME: parse rtcp.\n  return description;\n};\n\n// Generates parts of the SDP media section describing the capabilities /\n// parameters.\nSDPUtils.writeRtpDescription = function(kind, caps) {\n  let sdp = '';\n\n  // Build the mline.\n  sdp += 'm=' + kind + ' ';\n  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.\n  sdp += ' UDP/TLS/RTP/SAVPF ';\n  sdp += caps.codecs.map(codec => {\n    if (codec.preferredPayloadType !== undefined) {\n      return codec.preferredPayloadType;\n    }\n    return codec.payloadType;\n  }).join(' ') + '\\r\\n';\n\n  sdp += 'c=IN IP4 0.0.0.0\\r\\n';\n  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\\r\\n';\n\n  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\n  caps.codecs.forEach(codec => {\n    sdp += SDPUtils.writeRtpMap(codec);\n    sdp += SDPUtils.writeFmtp(codec);\n    sdp += SDPUtils.writeRtcpFb(codec);\n  });\n  let maxptime = 0;\n  caps.codecs.forEach(codec => {\n    if (codec.maxptime > maxptime) {\n      maxptime = codec.maxptime;\n    }\n  });\n  if (maxptime > 0) {\n    sdp += 'a=maxptime:' + maxptime + '\\r\\n';\n  }\n\n  if (caps.headerExtensions) {\n    caps.headerExtensions.forEach(extension => {\n      sdp += SDPUtils.writeExtmap(extension);\n    });\n  }\n  // FIXME: write fecMechanisms.\n  return sdp;\n};\n\n// Parses the SDP media section and returns an array of\n// RTCRtpEncodingParameters.\nSDPUtils.parseRtpEncodingParameters = function(mediaSection) {\n  const encodingParameters = [];\n  const description = SDPUtils.parseRtpParameters(mediaSection);\n  const hasRed = description.fecMechanisms.indexOf('RED') !== -1;\n  const hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;\n\n  // filter a=ssrc:... cname:, ignore PlanB-msid\n  const ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n    .map(line => SDPUtils.parseSsrcMedia(line))\n    .filter(parts => parts.attribute === 'cname');\n  const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\n  let secondarySsrc;\n\n  const flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')\n    .map(line => {\n      const parts = line.substr(17).split(' ');\n      return parts.map(part => parseInt(part, 10));\n    });\n  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\n    secondarySsrc = flows[0][1];\n  }\n\n  description.codecs.forEach(codec => {\n    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {\n      let encParam = {\n        ssrc: primarySsrc,\n        codecPayloadType: parseInt(codec.parameters.apt, 10),\n      };\n      if (primarySsrc && secondarySsrc) {\n        encParam.rtx = {ssrc: secondarySsrc};\n      }\n      encodingParameters.push(encParam);\n      if (hasRed) {\n        encParam = JSON.parse(JSON.stringify(encParam));\n        encParam.fec = {\n          ssrc: primarySsrc,\n          mechanism: hasUlpfec ? 'red+ulpfec' : 'red',\n        };\n        encodingParameters.push(encParam);\n      }\n    }\n  });\n  if (encodingParameters.length === 0 && primarySsrc) {\n    encodingParameters.push({\n      ssrc: primarySsrc,\n    });\n  }\n\n  // we support both b=AS and b=TIAS but interpret AS as TIAS.\n  let bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');\n  if (bandwidth.length) {\n    if (bandwidth[0].indexOf('b=TIAS:') === 0) {\n      bandwidth = parseInt(bandwidth[0].substr(7), 10);\n    } else if (bandwidth[0].indexOf('b=AS:') === 0) {\n      // use formula from JSEP to convert b=AS to TIAS value.\n      bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95\n          - (50 * 40 * 8);\n    } else {\n      bandwidth = undefined;\n    }\n    encodingParameters.forEach(params => {\n      params.maxBitrate = bandwidth;\n    });\n  }\n  return encodingParameters;\n};\n\n// parses http://draft.ortc.org/#rtcrtcpparameters*\nSDPUtils.parseRtcpParameters = function(mediaSection) {\n  const rtcpParameters = {};\n\n  // Gets the first SSRC. Note that with RTX there might be multiple\n  // SSRCs.\n  const remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n    .map(line => SDPUtils.parseSsrcMedia(line))\n    .filter(obj => obj.attribute === 'cname')[0];\n  if (remoteSsrc) {\n    rtcpParameters.cname = remoteSsrc.value;\n    rtcpParameters.ssrc = remoteSsrc.ssrc;\n  }\n\n  // Edge uses the compound attribute instead of reducedSize\n  // compound is !reducedSize\n  const rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');\n  rtcpParameters.reducedSize = rsize.length > 0;\n  rtcpParameters.compound = rsize.length === 0;\n\n  // parses the rtcp-mux attrÑ–bute.\n  // Note that Edge does not support unmuxed RTCP.\n  const mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');\n  rtcpParameters.mux = mux.length > 0;\n\n  return rtcpParameters;\n};\n\nSDPUtils.writeRtcpParameters = function(rtcpParameters) {\n  let sdp = '';\n  if (rtcpParameters.reducedSize) {\n    sdp += 'a=rtcp-rsize\\r\\n';\n  }\n  if (rtcpParameters.mux) {\n    sdp += 'a=rtcp-mux\\r\\n';\n  }\n  if (rtcpParameters.ssrc !== undefined && rtcpParameters.cname) {\n    sdp += 'a=ssrc:' + rtcpParameters.ssrc +\n      ' cname:' + rtcpParameters.cname + '\\r\\n';\n  }\n  return sdp;\n};\n\n\n// parses either a=msid: or a=ssrc:... msid lines and returns\n// the id of the MediaStream and MediaStreamTrack.\nSDPUtils.parseMsid = function(mediaSection) {\n  let parts;\n  const spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');\n  if (spec.length === 1) {\n    parts = spec[0].substr(7).split(' ');\n    return {stream: parts[0], track: parts[1]};\n  }\n  const planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n    .map(line => SDPUtils.parseSsrcMedia(line))\n    .filter(msidParts => msidParts.attribute === 'msid');\n  if (planB.length > 0) {\n    parts = planB[0].value.split(' ');\n    return {stream: parts[0], track: parts[1]};\n  }\n};\n\n// SCTP\n// parses draft-ietf-mmusic-sctp-sdp-26 first and falls back\n// to draft-ietf-mmusic-sctp-sdp-05\nSDPUtils.parseSctpDescription = function(mediaSection) {\n  const mline = SDPUtils.parseMLine(mediaSection);\n  const maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');\n  let maxMessageSize;\n  if (maxSizeLine.length > 0) {\n    maxMessageSize = parseInt(maxSizeLine[0].substr(19), 10);\n  }\n  if (isNaN(maxMessageSize)) {\n    maxMessageSize = 65536;\n  }\n  const sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');\n  if (sctpPort.length > 0) {\n    return {\n      port: parseInt(sctpPort[0].substr(12), 10),\n      protocol: mline.fmt,\n      maxMessageSize,\n    };\n  }\n  const sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');\n  if (sctpMapLines.length > 0) {\n    const parts = sctpMapLines[0]\n      .substr(10)\n      .split(' ');\n    return {\n      port: parseInt(parts[0], 10),\n      protocol: parts[1],\n      maxMessageSize,\n    };\n  }\n};\n\n// SCTP\n// outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers\n// support by now receiving in this format, unless we originally parsed\n// as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line\n// protocol of DTLS/SCTP -- without UDP/ or TCP/)\nSDPUtils.writeSctpDescription = function(media, sctp) {\n  let output = [];\n  if (media.protocol !== 'DTLS/SCTP') {\n    output = [\n      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\\r\\n',\n      'c=IN IP4 0.0.0.0\\r\\n',\n      'a=sctp-port:' + sctp.port + '\\r\\n',\n    ];\n  } else {\n    output = [\n      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\\r\\n',\n      'c=IN IP4 0.0.0.0\\r\\n',\n      'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\\r\\n',\n    ];\n  }\n  if (sctp.maxMessageSize !== undefined) {\n    output.push('a=max-message-size:' + sctp.maxMessageSize + '\\r\\n');\n  }\n  return output.join('');\n};\n\n// Generate a session ID for SDP.\n// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1\n// recommends using a cryptographically random +ve 64-bit value\n// but right now this should be acceptable and within the right range\nSDPUtils.generateSessionId = function() {\n  return Math.random().toString().substr(2, 21);\n};\n\n// Write boiler plate for start of SDP\n// sessId argument is optional - if not supplied it will\n// be generated randomly\n// sessVersion is optional and defaults to 2\n// sessUser is optional and defaults to 'thisisadapterortc'\nSDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {\n  let sessionId;\n  const version = sessVer !== undefined ? sessVer : 2;\n  if (sessId) {\n    sessionId = sessId;\n  } else {\n    sessionId = SDPUtils.generateSessionId();\n  }\n  const user = sessUser || 'thisisadapterortc';\n  // FIXME: sess-id should be an NTP timestamp.\n  return 'v=0\\r\\n' +\n      'o=' + user + ' ' + sessionId + ' ' + version +\n        ' IN IP4 127.0.0.1\\r\\n' +\n      's=-\\r\\n' +\n      't=0 0\\r\\n';\n};\n\n// Gets the direction from the mediaSection or the sessionpart.\nSDPUtils.getDirection = function(mediaSection, sessionpart) {\n  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\n  const lines = SDPUtils.splitLines(mediaSection);\n  for (let i = 0; i < lines.length; i++) {\n    switch (lines[i]) {\n      case 'a=sendrecv':\n      case 'a=sendonly':\n      case 'a=recvonly':\n      case 'a=inactive':\n        return lines[i].substr(2);\n      default:\n        // FIXME: What should happen here?\n    }\n  }\n  if (sessionpart) {\n    return SDPUtils.getDirection(sessionpart);\n  }\n  return 'sendrecv';\n};\n\nSDPUtils.getKind = function(mediaSection) {\n  const lines = SDPUtils.splitLines(mediaSection);\n  const mline = lines[0].split(' ');\n  return mline[0].substr(2);\n};\n\nSDPUtils.isRejected = function(mediaSection) {\n  return mediaSection.split(' ', 2)[1] === '0';\n};\n\nSDPUtils.parseMLine = function(mediaSection) {\n  const lines = SDPUtils.splitLines(mediaSection);\n  const parts = lines[0].substr(2).split(' ');\n  return {\n    kind: parts[0],\n    port: parseInt(parts[1], 10),\n    protocol: parts[2],\n    fmt: parts.slice(3).join(' '),\n  };\n};\n\nSDPUtils.parseOLine = function(mediaSection) {\n  const line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];\n  const parts = line.substr(2).split(' ');\n  return {\n    username: parts[0],\n    sessionId: parts[1],\n    sessionVersion: parseInt(parts[2], 10),\n    netType: parts[3],\n    addressType: parts[4],\n    address: parts[5],\n  };\n};\n\n// a very naive interpretation of a valid SDP.\nSDPUtils.isValidSDP = function(blob) {\n  if (typeof blob !== 'string' || blob.length === 0) {\n    return false;\n  }\n  const lines = SDPUtils.splitLines(blob);\n  for (let i = 0; i < lines.length; i++) {\n    if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {\n      return false;\n    }\n    // TODO: check the modifier a bit more.\n  }\n  return true;\n};\n\n// Expose public methods.\nif (typeof module === 'object') {\n  module.exports = SDPUtils;\n}\n"]},"metadata":{},"sourceType":"script"}